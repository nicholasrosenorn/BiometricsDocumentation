# Data Architects 

## What is a database?

A database is an organized collection of data stored electronically. It is typically controlled by a database management system (DBMS). There are two main categories a database can fall into: relational and non-relational. A relational database is one that stores data in rows and columns, otherwise known as a table. While a simple database may include only one table, a typical functional database contains multiple tables. These tables are linked to each other using keys. A primary key is a unique identifier and is referenced by other tables. When in another table, it is considered a foreign key. While it is not necessary, it is common practice to include a primary key in every table. Nearly all relational databases rely on the programming language SQL (Structured Query Language) to query, manipulate, and define data, as well as provide access control. 

The term “non-relational database” is a blanket term for all other databases that do not rely on SQL, hence their other name, NoSQL. These databases can take on many forms: key-value store, document store, column-oriented databases, and graph databases, to name a few.

## How to create the database: 

First step would be to download mySQL on a machine.
https://www.mysql.com/ is the website where the software can be downloaded. 
Click on “Downloads” on the top of the tabs, and scroll down to click on MySQL Community (GPL) Downloads. Next click on “MySQL Community Downloads”. Please select the correct operating system based on your machine type. Also, make sure to check system versions and download archives based on the critias. After downloading this go back and click on MySQL Workbench downloads. Make sure to follow the previous instructions and download the workbench similar to how communities were downloaded. 

Once everything is downloaded please go into mySQL.  Make sure to set a good password for your connection. Once in MySQL click on Local instance. The script for the database including the comments it written below. In order to transfer the database into your own system please paste the script into your mySQL. After pasting everything in click on the lighting shape button with a one symbol to run your code. 


## Basic SQL key:

-- (Whenever there is a comment amongst the code this is typed before the comment. Similar to # in python) 

VARCHAR(): this is character data. The number in the parenthesis is the amount of characters in the word saved in the tables.

FLOAT: this stores an approximate value and decimal. An example would be that monet data would use FLOAT.

INT: This is a data type that is a primary integer data type. 



## MySQL Script: 

-- This is the code that loads different settings into your database.
-- MySQL Workbench Forward Engineering
 
/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
 
-- This is the first table for the Merck database. CREATE TABLE IF NOT EXISTS notifies mySQL to create a new table. After this would be the name for the table. 
-- -----------------------------------------------------
-- Schema Merck database
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `Merck database` DEFAULT CHARACTER SET utf8 ;
USE `Merck database` ;
 -- -----------------------------------------------------
-- Table `Merck database`.`User`: This table will store information for the website. When the user first creates an account. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User` (
  `id` INT NOT NULL,
  `username` VARCHAR(20) NOT NULL,
  `First_Name` VARCHAR(100) NOT NULL,
  `Last_Name` VARCHAR(100) NOT NULL,
  `date_of_birth` INT NOT NULL,
  `Height` INT NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `username_UNIQUE` (`username` ASC))
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`MerckData`: This is the table that will store the written data in the website. 
-- ------------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`MerckData` (
  `ID` INT NOT NULL,
  `input_date` INT NOT NULL,
  `family_history_cancer` VARCHAR(500) NULL,
  `Family_history_heart_disease` VARCHAR(500) NULL,
  `diagnostic_notes` VARCHAR(500) NULL,
  PRIMARY KEY (`ID`))
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`Pain_Data`: This is the data that the patient inputs themselves. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`Pain_Data` (
  `Username` VARCHAR(20) NOT NULL,
  `input_date` DATETIME NOT NULL,
  `happiness` FLOAT NULL,
  `Sleep` FLOAT NULL,
  `hours_worked` FLOAT NULL,
  `Symptoms` VARCHAR(100) NULL,
  `Meals` FLOAT NULL,
  `medication_timing` VARCHAR(200) NULL,
  `smoking_alcohol` VARCHAR(200) NULL,
  `Other_medication` VARCHAR(200) NULL,
  `water_intake` FLOAT NULL,
  `diagnosis` VARCHAR(300) NULL,
  PRIMARY KEY (`Username`))
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`User_MerckData`: This is the script that will connect the Merck database and User_MerckData. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User_MerckData` (
  `User_id` INT NOT NULL,
  `MerckData_ID` INT NOT NULL,
  PRIMARY KEY (`User_id`, `MerckData_ID`),
  INDEX `fk_User_has_MerckData_MerckData1_idx` (`MerckData_ID` ASC),
  INDEX `fk_User_has_MerckData_User_idx` (`User_id` ASC),
  CONSTRAINT `fk_User_has_MerckData_User`
	FOREIGN KEY (`User_id`)
	REFERENCES `Merck database`.`User` (`id`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION,
  CONSTRAINT `fk_User_has_MerckData_MerckData1`
	FOREIGN KEY (`MerckData_ID`)
	REFERENCES `Merck database`.`MerckData` (`ID`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION)
ENGINE = InnoDB;
-- -----------------------------------------------------
-- Table `Merck database`.`User_Pain_Data`: This is the script that will connect the Merck database and User_pain_data. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User_Pain_Data` (
  `User_id` INT NOT NULL,
  `Pain_Data_Username` VARCHAR(20) NOT NULL,
  PRIMARY KEY (`User_id`, `Pain_Data_Username`),
  INDEX `fk_User_has_Pain_Data_Pain_Data1_idx` (`Pain_Data_Username` ASC),
  INDEX `fk_User_has_Pain_Data_User1_idx` (`User_id` ASC),
  CONSTRAINT `fk_User_has_Pain_Data_User1`
	FOREIGN KEY (`User_id`)
	REFERENCES `Merck database`.`User` (`id`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION,
  CONSTRAINT `fk_User_has_Pain_Data_Pain_Data1`
	FOREIGN KEY (`Pain_Data_Username`)
	REFERENCES `Merck database`.`Pain_Data` (`Username`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION)
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`FitBit_Data`: This is the table that will store data from the Fitbit. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`FitBit_Data` (
  `Username` INT NOT NULL,
  `Collection_Date` INT NOT NULL,
  `Steps` VARCHAR(45) NULL,
  `Floors_climbed` FLOAT NULL,
  `total_miles` FLOAT NULL,
  `Lightly_Active_miles` FLOAT NULL,
  `moderately_active_miles` FLOAT NULL,
  `Very_active_miles` FLOAT NULL,
  `Lightly_active_minutes` FLOAT NULL,
  `fairly_active_minutes` FLOAT NULL,
  `very_active_minutes` FLOAT NULL,
  `hr30-100_minutes` FLOAT NULL,
  `hr100-140_minutes` FLOAT NULL,
  `hr140-170_ minutes` FLOAT NULL,
  `hr170_220_minutes` FLOAT NULL,
  `average_resting_hr` FLOAT NULL,
  `bmi` FLOAT NULL,
  `minutes_asleep` FLOAT NULL,
  `sleep_efficiency` FLOAT NULL,
  `Weight` FLOAT NULL,
  `Stress_score` INT NULL,
  `Blood_oxygen_saturation` INT NULL,
  PRIMARY KEY (`Username`))
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`Apple_Data`: This is the table that will store the Apple Watch data. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`Apple_Data` (
  `Username` VARCHAR(20) NOT NULL,
  `Collection_Date` INT NULL,
  `Steps` INT NULL,
  `activeEnergyBurned` FLOAT NULL,
  `activeEnergyBurnedGoal` FLOAT NULL,
  `activeEnergyBurnedUnit` FLOAT NULL,
  `appleExerciseTime` FLOAT NULL,
  `appleExerciseTimeGoal` FLOAT NULL,
  `appleStandHours` FLOAT NULL,
  `appleStandHoursGoal` FLOAT NULL,
  `sourceName` FLOAT NULL,
  `sourceVersion` FLOAT NULL,
  `device` FLOAT NULL,
  `type` FLOAT NULL,
  `unit` FLOAT NULL,
  `creationDate` FLOAT NULL,
  `startDate` FLOAT NULL,
  `endDate` FLOAT NULL,
  `value` FLOAT NULL,
  `workoutActivityType` FLOAT NULL,
  `duration` FLOAT NULL,
  `durationUnit` VARCHAR(45) NULL,
  `totalDistance` VARCHAR(45) NULL,
  `totalDistanceUnit` VARCHAR(45) NULL,
  `totalEnergyBurned` VARCHAR(45) NULL,
  `totalEnergyBurnedUnit` VARCHAR(45) NULL,
  PRIMARY KEY (`Username`))
ENGINE = InnoDB;
-- -----------------------------------------------------
-- Table `Merck database`.`Garmin_Data`: This table will store the data from the Garmin Watch. 
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`Garmin_Data` (
  `Username` VARCHAR(20) NOT NULL,
  `Collection_Date` INT NULL,
  `Steps` INT NULL,
  `floors_climbed` FLOAT NULL,
  `total_miles` FLOAT NULL,
  `lightly_active_miles` FLOAT NULL,
  `moderately_active_miles` FLOAT NULL,
  `Very_active_miles` FLOAT NULL,
  `Sedentary_minutes` FLOAT NULL,
  `lightly_active_minutes` FLOAT NULL,
  `fairly_active_minutes` FLOAT NULL,
  `very_active_minutes` FLOAT NULL,
  `hr30-100_minutes` FLOAT NULL,
  `hr100-140_minutes` FLOAT NULL,
  `hr140-170_minutes` FLOAT NULL,
  `hr170-220_minutes` FLOAT NULL,
  `average_resting_hr` FLOAT NULL,
  `bmi` VARCHAR(45) NULL,
  PRIMARY KEY (`Username`))
ENGINE = InnoDB;
-- -----------------------------------------------------
-- Table `Merck database`.`User_Apple_Data`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User_Apple_Data` (
  `User_id` INT NOT NULL,
  `Apple_Data_Username` VARCHAR(20) NOT NULL,
  PRIMARY KEY (`User_id`, `Apple_Data_Username`),
  INDEX `fk_User_has_Apple_Data_Apple_Data1_idx` (`Apple_Data_Username` ASC),
  INDEX `fk_User_has_Apple_Data_User1_idx` (`User_id` ASC),
  CONSTRAINT `fk_User_has_Apple_Data_User1`
	FOREIGN KEY (`User_id`)
	REFERENCES `Merck database`.`User` (`id`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION,
  CONSTRAINT `fk_User_has_Apple_Data_Apple_Data1`
	FOREIGN KEY (`Apple_Data_Username`)
	REFERENCES `Merck database`.`Apple_Data` (`Username`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION)
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`User_Garmin_Data`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User_Garmin_Data` (
  `User_id` INT NOT NULL,
  `Garmin_Data_Username` INT NOT NULL,
  PRIMARY KEY (`User_id`, `Garmin_Data_Username`),
  INDEX `fk_User_has_Garmin_Data_Garmin_Data1_idx` (`Garmin_Data_Username` ASC),
  INDEX `fk_User_has_Garmin_Data_User1_idx` (`User_id` ASC),
  CONSTRAINT `fk_User_has_Garmin_Data_User1`
	FOREIGN KEY (`User_id`)
	REFERENCES `Merck database`.`User` (`id`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION,
  CONSTRAINT `fk_User_has_Garmin_Data_Garmin_Data1`
	FOREIGN KEY (`Garmin_Data_Username`)
	REFERENCES `Merck database`.`Garmin_Data` (`Username`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION)
ENGINE = InnoDB;
 -- -----------------------------------------------------
-- Table `Merck database`.`User_Fitbit_Data`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `Merck database`.`User_Fitbit_Data` (
  `User_id` INT NOT NULL,
  `Fitbit_Data_Username` VARCHAR(20) NOT NULL,
  PRIMARY KEY (`User_id`, `Fitbit_Data_Username`),
  INDEX `fk_User_has_Fitbit_Data_Fitbit_Data1_idx` (`Fitbit_Data_Username` ASC),
  INDEX `fk_User_has_Fitbit_Data_User1_idx` (`User_id` ASC),
  CONSTRAINT `fk_User_has_Fitbit_Data_User1`
	FOREIGN KEY (`User_id`)
	REFERENCES `Merck database`.`User` (`id`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION,
  CONSTRAINT `fk_User_has_Fitbit_Data_Fitbit_Data1`
	FOREIGN KEY (`Fitbit_Data_Username`)
	REFERENCES `Merck database`.`Fitbit_Data` (`Username`)
	ON DELETE NO ACTION
	ON UPDATE NO ACTION)
ENGINE = InnoDB;
 
 -- This is the code that will package the whole script. 
 
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
 

## How to connect the SQL database to AWS:
 
Make sure to replace the host name with the correct one that connects to the AWS account. Next enter your username, and lastly enter in the password that associates with the account. If the error of admin access comes up. It would be best to send the AWS account owner the SQL script and they can directly connect it from their machine. This error has come up before and this was one of the fastest ways to solve this problem.

## How to load dummy data into mySQL:

A key part of loading dummy data into mySQL is looking at the table columns. The first step in the process is finding dummy data and formatting this into a CSV file. After this it’s important to make sure the dummy data columns align with the column values in the database. For example we had to change a couple of columns in the database such as floors climbed to keep the data collected by the database accurate. The lines we used to load the dummy data into the apple watch table and fitbit data below:

```{r, eval = FALSE}
load data local infile "fitbit.csv" into table Fitbit_Data
FIELDS TERMINATED BY ',' 
	 lines terminated by '\n'
     ignore 1 rows
     (Username, Collection_Date, Steps, floors_climbed, total_miles, lightly_active_miles,
     moderately_active_miles, very_active_miles, sedentary_minutes,
     lightly_active_minutes, fairly_active_minutes,
     very_active_mintes,  
     hr30_100_minutes,
     hr100_140_minutes, hr140_170_minutes, hr170_220_minutes, average_resting_hr, bmi, minutes_asleep, sleep_efficiency, Weight)



load data local infile "ActivitySummary.csv" into table Apple_Data
FIELDS TERMINATED BY ',' 
	 lines terminated by '\n'
     ignore 1 rows
     (dataComponents, 
activeEnergyBurned, activeEnergyBurnedGoal, 
activeEnergyBurnedUnit,
appleExerciseTime,
appleExerciseTimeGoal,
appleStandHours,
appleStandHoursGoal,)


load data local infile "DistanceWalkingRunning.csv" into table Apple_Data
FIELDS TERMINATED BY ',' 
	 lines terminated by '\n'
     ignore 1 rows
     (sourceName, 
sourceVersion, device, 
Type,
unit,
creationDate
startDate,
endDate,
value)

load data local infile 
"StepCount.csv" into table Apple_Data
FIELDS TERMINATED BY ',' 
	 lines terminated by '\n'
     ignore 1 rows
     (sourceName, 
sourceVersion, device, 
Type,
unit,
creationDate
startDate,
endDate,
value)

load data local infile 
"Workout.csv" into table Apple_Data
FIELDS TERMINATED BY ',' 
	 lines terminated by '\n'
     ignore 1 rows
     (sourceName, 
sourceVersion, device, 
Type,
unit,
creationDate
startDate,
endDate,
workoutActivityType,
Duration,
durationUnit, 
totalDistance,
totalDistanceUnit,
totalEnergyBurned,
totalEnergyBurnedUnit)
```



## Database Creation with Neo4j
Neo4j is a graph database created by Neo4j inc. Neo4j is implemented in Java; however, it
can also be written with any other cypher query language.

1. create(u:user {name:'User'})-[:makes]->(n:user{name:'Username'})
return u,n

Instead of creating a new nodefor User we can just match the node with the new node you want to create. The create section describes the relationships between the two nodes. The ‘User’ and ‘Username’ section is the code for the new node. The return section is the
code for return which would store the nodes into the system.

2.
match (u:User{name : 'User'}) Create (u)-[: Enters] -> (DA : User{name : 'Date Of Birth'})
Return u,DA

The match statement creates relationships between 2 nodes. This line of code codes for a new node “Last Name” which stores the last name of the patient. This node holds a relationship with the User node. 

3. match(u:user {name:'User'}) create (u)- [:enters]-> (LN:user{name:'Last Name'}) return u,LN 

Similar to the code on the third line. A new node has been created, however this node is created to store the last name of the user. 

4. match(u:user {name:'User'}) create (u)- [:enters]-> (FN:user{name:'First Name'}) return u,FN 

A new node is created with this code. The node stores the Height of the user. 

5. match(u:user {name:'User'}) create (u)- [:enters]-> (H:user{name:'Height'}) return u,H 
The ID node is created, thus allowing for the user id to be stored. 

6. match(u:user {name:'User'}) create (u)- [:enters]-> (I:user{name:'ID'}) return u,I 

This line of code codes for a new node “Merck Data” which stores the last name of the patient. This node holds a relationship with the ID node. 

7. match(I:user{name:'ID'}) create (I)- [:enters]-> (M:user{name:'Merck Data'}) return I,M 

This line of code codes for a new node “Family History Cancers” which stores the family history cancers of the patient. This node holds a relationship with the Merck Data node. 

8. match(M:user{name:'Merck Data'}) create (M)- [:enters]-> (FH:user{name:'Family History Cancers'}) return M,FH 

Lines 9, 10, and 11 all code for three new nodes “Diagnostic notes”, “ Any other family history disease”, and “Input Data”. This node holds a relationship with the Merck Data node. 

9. match(M:user{name:'Merck Data'}) create (M)- [:enters]-> (ID:user{name:'Input Data'}) return M,ID 
10. match(M:user{name:'Merck Data'}) create (M)- [:enters]-> (DN:user{name:'Diagnostic Notes'}) return M,DN 
11. match(M:user{name:'Merck Data'}) create (M)- [:enters]-> (AD:user{name:'Any other family history in disease'}) return M,AD 

This line of code helps put together all of the nodes. This is to help you check your database while you add new nodes. This line of code will be used throughout to double check the code, and to endure every branch is in the correct spot. 


12. MATCH (n:user) RETURN n LIMIT 100 

This code creates the relationship between the node “Username” and the new node “fitbit data”. The new node will store fitbit data. 

13. match(n:user{name:'Username'}) create (n)- [:enters]-> (FD:user{name:'FitBit Data'}) return n, FD 
14. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (WE:user{name:'Weight'}) return FD,WE 
15. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (CD:user{name:'Collection Date'}) return FD,CD 
16. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (B:user{name:'BMI'}) return FD,B 
17. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (FC:user{name:'Floors Climbed'}) return FD,FC 
18. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (ARH:user{name:'Average Resting Hr'}) return FD,ARH 
19. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (ST:user{name:'Steps'}) return FD,ST 

This line of code codes for a new node “Miles” which stores the miles of the patient. This node holds a relationship with the Fitbit Data Node 

20. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (Mi:user{name:'Miles'}) return FD,Mi 
Lines 20,21,22,23,24,25 all code for new nodes that hold relationships with the Fitbit node. 
21. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (TM:user{name:'Total Miles'}) return FD,TM 
22. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (VAM:user{name:'Very Active Miles'}) return FD,VAM 
23. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (LAM:user{name:'Lightly Active Miles'}) return FD,LAM 
24. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (MAM:user{name:'Moderately Active Miles'}) return FD,MAM 
25. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (S:user{name:'Sleep'}) return FD,S 

Lines 26,27 all codes for new nodes that holds relationships with the “Sleep node”. 

26. match(S:user{name:'Sleep'}) create (S)- [:enters]-> (SE:user{name:'Sleep Efficiency'}) return S,SE 
27. match(S:user{name:'Sleep'}) create (S)- [:enters]-> (MAS:user{name:'Minutes Asleep'}) return S,MAS 
Lines 28,29,30,31,32,33,34,35,36 all codes for new nodes that hold relationships with the “minute node”. 
28. match(FD:user{name:'FitBit Data'}) create (FD)- [:enters]-> (M:user{name:'Minutes'}) return FD,M 
29. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (OF:user{name:'hr 140-170'}) return M,OF 
30. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (SM:user{name:'Sedentary Minutes'}) return M,SM 
31. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (LAM:user{name:'Lightly Active Minutes'}) return M,LAM 
32. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (FAM:user{name:'Fairly Active Minutes'}) return M,FAM 
33. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (VAM:user{name:'Very Active Minutes'}) return M,VAM 
34. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (HR:user{name:'hr 30-100'}) return M,HR 
35. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (HR1:user{name:'hr 100-140'}) return M,HR1 
36. match(M:user{name:'Minutes'}) create (M)- [:enters]-> (HR2:user{name:'hr 170-220'}) return M,HR2 

Lines 37-49 all codes for new nodes that hold relationships with the “Pain Data” node. The portions after ‘name’ are the new nodes. 

37. MATCH (n:user) RETURN n LIMIT 100 
38. match(u:user {name:'User'}) create (u)- [:enters]-> (PD:user{name:'Pain Data'}) return u,PD 
39. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (D:user{name:'Diagnosis'}) return PD,D 
40. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (WI:user{name:'Water Intake'}) return PD,WI 
41. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (MT:user{name:'Medication Timing'}) return PD,MT 
42. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (DA:user{name:'Date'}) return PD,DA 
43. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (HA:user{name:'Happiness'}) return PD,HA 
44. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (OM:user{name:'Other Medication'}) return PD,OM 
45. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (SL:user{name:'Sleep'}) return PD,SL 
46. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (HW:user{name:'Hours Worked'}) return PD,HW 
47. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (US:user{name:'Unusual Symptoms'}) return PD,US 
48. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (M:user{name:'meals'}) return PD,M 
49. match(PD:user{name:'Pain Data'}) create (PD)- [:enters]-> (SA:user{name:'Smoking/Alcohol'}) return PD,SA 

## Inputting Dummy Data into Fitbit Neo4j Database
After creating the Database, this semester we were able to input dummy data into the Fitbit database. After uploading Dr. Ward’s fitbit data into Neo4j, I was able to put the data into the database by changing the names of the nodes to fit the name of the columns on Dr. Wards fitbit data csv. I was able to run tests and find results using Dr. Wards sample data and the fitbit neo4j database. 

## Challenges with Creating Neo4j Database
While creating the Neo4j database, we ran into issues while trying to properly represent things that were shared between multiple nodes (patient ID for example).  To make it known that this was being collected or entered in each node, we had to make sure it was included as a branch for each main node.  We also had to make sure that each datapoint had the correct representation of whether it was being collected or entered by the patient.
